[{"categories":["Block Chain","Chainlink"],"contents":"今天我们分析chainlink合约源码。\nChainlinkClient.sol 位置ChainlinkClient.sol\n主要代码 /** * @notice 构建一个ChainlinkRequest * @param _specId node 节点创建的jobId * @param _callbackAddress 请求成功数据回调的地址 * @param _callbackFunctionSignature 回调地址对应的function * @return A Chainlink Request struct in memory */ function buildChainlinkRequest( bytes32 _specId, address _callbackAddress, bytes4 _callbackFunctionSignature ) internal pure returns (Chainlink.Request memory) { Chainlink.Request memory req; return req.initialize(_specId, _callbackAddress, _callbackFunctionSignature); } /** * @notice 向指定的oracle地址创建一个请求 * @dev 创建并存储一个请求ID, 增加本地的nonce值, 并使用`transferAndCall` 方法发送LINK， * 创建到目标oracle合约地址的请求 * 发出 ChainlinkRequested 事件. * @param _oracle 发送请求至的oracle地址 * @param _req 完成初始化的Chainlink请求 * @param _payment 请求发送的LINK数量 * @return 请求 ID */ function sendChainlinkRequestTo(address _oracle, Chainlink.Request memory _req, uint256 _payment) internal returns (bytes32 requestId) { requestId = keccak256(abi.encodePacked(this, requestCount)); _req.nonce = requestCount; pendingRequests[requestId] = _oracle; emit ChainlinkRequested(requestId); require(link.transferAndCall(_oracle, _payment, encodeRequest(_req)), \u0026quot;unable to transferAndCall to oracle\u0026quot;); requestCount += 1; return requestId; } /** * @notice 取消一个还没有回调的ChainlinkRequest * @dev 需要记录录一个过期值 * 从pendingRequests删除对应request * 触发ChainlinkCancelled事件 * @param _requestId The request ID * @param _payment 请求发送的LINK数量 * @param _callbackFunc 请求回调指定的function * @param _expiration 请求过期的时间 */ function cancelChainlinkRequest( bytes32 _requestId, uint256 _payment, bytes4 _callbackFunc, uint256 _expiration ) internal { ChainlinkRequestInterface requested = ChainlinkRequestInterface(pendingRequests[_requestId]); delete pendingRequests[_requestId]; emit ChainlinkCancelled(_requestId); requested.cancelOracleRequest(_requestId, _payment, _callbackFunc, _expiration); } 其中 link.transferAndCall 方法即是 ERC677 定义的 token 转账方法，与 ERC20 的 transfer 方法相比，它多了一个 data 字段，可以在转账的同时携带数据。这里就将之前打包好的请求数据放在了 data 字段，跟随转账一起发送到了 Oracle 合约。transferAndCall 方法定义如下\n/** * @dev 将token和额外数据一起转移给一个合约地址 * @param _to 转移到的目的地址 * @param _value 转移数量 * @param _data 传递给接收合约的额外数据 */ function transferAndCall(address _to, uint _value, bytes _data) public returns (bool success) { } ","permalink":"https://link2.guru/blog/chainlink%E5%90%88%E7%BA%A6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/","tags":["Chainlink"],"title":"chainlink合约源码分析（1）"},{"categories":["Block Chain"],"contents":"注册钱包 首先你创建主网钱包地址，并激活。wallet.near.org\n部署主网节点（非验证节点）  clone nearcore  git clone https://github.com/near/nearcore.git 设置环境变量  export NEAR_RELEASE_VERSION=$(curl -s https://github.com/near/nearcore/releases/latest | tr '/\u0026quot; ' '\\n' | grep \u0026quot;[0-9]\\.[0-9]*\\.[0-9]\u0026quot; | head -n 1) 3 切换分支\ncd nearcore git checkout $NEAR_RELEASE_VERSION 构建nearcore,时间比较长，耐心等待。  cargo build -p neard --release 5.配置chain-id和account-id\ntarget/release/neard init --chain-id=\u0026quot;mainnet\u0026quot; --account-id=\u0026lt;YOUR_STAKING_POOL_ID\u0026gt; 启动节点  6.1 修改config.json配置文件。\n使用config.json覆盖.near/config.json\n6.2 防火墙需要打开24567端口\n6.3 运行下面命令\ntarget/release/neard run 节点已经运行，等待同步就可以了。\nRPC端口:3030。\n使用tmux后台云运行  参考 deploy-on-mainnet\n","permalink":"https://link2.guru/blog/how-to-run-mainnet-on-near/","tags":["Near"],"title":"运行Near主网节点（非验证节点）"}]