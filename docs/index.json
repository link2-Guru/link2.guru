[{"categories":["Block Chain","Binance Smart Chain"],"contents":"介绍 您可能听说过原生代币为币安币（BNB）的币安链（Binance Chain），它针对快速交易进行了优化。为了实现速度，它必须做出一定的权衡–一方面从可编程角度来说，它牺牲了其它区块链的灵活性。\n但币安智能链（Binance Smart Chain）对此进行了改变。币安智能链是个具有成熟环境的新区块链，用于开发高性能去中心化应用程序。它旨在与币安链进行跨链兼容性，以确保用户兼得两者优势。\n本质上两个区块链都是并行的。值得注意的是BSC并非所谓的第二层或链外扩展性解决方案。它是一个即使币安链下线后也可以运行的独立区块链。从设计的角度来看，这两个链非常相似。\n由于BSC与EVM兼容，因此它支持以太坊工具和DApp。理论上讲这使开发人员可以轻松地从以太坊移植其项目。对于用户而言，这表示他们可以轻松配置诸如MetaMask之类的应用程序与BSC一起使用，只需调整几个设置即可。\n启动节点 1.1 安装go golang官网\ngo version 1.2 启动bsc wget --no-check-certificate https://github.com/binance-chain/bsc/releases/download/v1.0.4/geth_linux ## mainet wget --no-check-certificate $(curl -s https://api.github.com/repos/binance-chain/bsc/releases/latest |grep browser_ |grep mainnet |cut -d\\\u0026quot; -f4) unzip mainnet.zip ## testnet wget --no-check-certificate $(curl -s https://api.github.com/repos/binance-chain/bsc/releases/latest |grep browser_ |grep testnet |cut -d\\\u0026quot; -f4) unzip testnet.zip geth --datadir node init genesis.json ## start a full node geth --config ./config.toml --datadir ./node --pprofaddr 0.0.0.0 --metrics --pprof RPC geth --rpc 默认端口 8545\n测试\ncurl --location --request POST '127.0.0.1:8545' \\ --header 'Content-Type: application/json' \\ --data-raw '{ \u0026quot;jsonrpc\u0026quot;:\u0026quot;2.0\u0026quot;, \u0026quot;method\u0026quot;:\u0026quot;net_version\u0026quot;, \u0026quot;params\u0026quot;:[], \u0026quot;id\u0026quot;:67 }' 返回成功\n{ \u0026quot;jsonrpc\u0026quot;: \u0026quot;2.0\u0026quot;, \u0026quot;id\u0026quot;: 67, \u0026quot;result\u0026quot;: \u0026quot;56\u0026quot; }  其它endpoints  https://bsc-dataseed.binance.org/ https://bsc-dataseed1.defibit.io/ https://bsc-dataseed1.ninicoin.io/ postman\n参考  bsc node bsc rpc ","permalink":"https://link2.guru/blog/bsc/bsc-%E5%B8%81%E5%AE%89%E6%99%BA%E8%83%BD%E9%93%BE%E5%BC%80%E5%8F%91%E7%B3%BB%E5%88%97%E4%B8%80/","tags":["Binance Smart Chain"],"title":"BSC 币安智能链开发系列一"},{"categories":["Block Chain","Chainlink"],"contents":"今天我们分析chainlink合约源码。\n Oracle.sol Oracle 合约在收到转账之后，会触发 onTokenTransfer 方法，该方法会检查转账的有效性，并通过发出 OracleRequest 事件记录更为详细的数据信息 位置Oracle.sol\n主要代码 /// LinkTokenReceiver.sol /** * @notice Called when LINK is sent to the contract via `transferAndCall` * @dev The data payload's first 2 words will be overwritten by the `_sender` and `_amount` * values to ensure correctness. Calls oracleRequest. * @param _sender Address of the sender * @param _amount Amount of LINK sent (specified in wei) * @param _data Payload of the transaction */ function onTokenTransfer( address _sender, uint256 _amount, bytes memory _data ) public onlyLINK validRequestLength(_data) permittedFunctionsForLINK(_data) { assembly { // solhint-disable-next-line avoid-low-level-calls mstore(add(_data, 36), _sender) // ensure correct sender is passed // solhint-disable-next-line avoid-low-level-calls mstore(add(_data, 68), _amount) // ensure correct amount is passed } // solhint-disable-next-line avoid-low-level-calls // 调用 oracleRequest (bool success, ) = address(this).delegatecall(_data); // calls oracleRequest require(success, \u0026quot;Unable to create request\u0026quot;); }  /// Oracle.sol /** * @notice 构造函数 初始化的时候传入link代币的地址 * @dev * @param _link The address of the LINK token */ constructor(address _link) public Ownable() { LinkToken = LinkTokenInterface(_link); // external but already deployed and unalterable } /** * @notice Creates the Chainlink request * @dev Stores the hash of the params as the on-chain commitment for the request. * Emits OracleRequest event for the Chainlink node to detect. * @param _sender The sender of the request * @param _payment The amount of payment given (specified in wei) * @param _specId The Job Specification ID * @param _callbackAddress The callback address for the response * @param _callbackFunctionId The callback function ID for the response * @param _nonce The nonce sent by the requester * @param _dataVersion The specified data version * @param _data The CBOR payload of the request */ function oracleRequest( address _sender, uint256 _payment, bytes32 _specId, address _callbackAddress, bytes4 _callbackFunctionId, uint256 _nonce, uint256 _dataVersion, bytes calldata _data ) external override onlyLINK() checkCallbackAddress(_callbackAddress) { bytes32 requestId = keccak256(abi.encodePacked(_sender, _nonce)); require(commitments[requestId] == 0, \u0026quot;Must use a unique ID\u0026quot;); // solhint-disable-next-line not-rely-on-time uint256 expiration = now.add(EXPIRY_TIME); commitments[requestId] = keccak256( abi.encodePacked( _payment, _callbackAddress, _callbackFunctionId, expiration ) ); emit OracleRequest( _specId, _sender, requestId, _payment, _callbackAddress, _callbackFunctionId, expiration, _dataVersion, _data); } /** * @notice 给节点设置权限 * @param _node The address of the Chainlink node * @param _allowed Bool value to determine if the node can fulfill requests */ function setFulfillmentPermission(address _node, bool _allowed) external override onlyOwner() { authorizedNodes[_node] = _allowed; } /** * @notice 允许用户取消请求 * sent for the request back to the requester's address. * @dev Given params must hash to a commitment stored on the contract in order for the request to be valid * Emits CancelOracleRequest event. * @param _requestId The request ID * @param _payment The amount of payment given (specified in wei) * @param _callbackFunc The requester's specified callback address * @param _expiration The time of the expiration for the request */ function cancelOracleRequest( bytes32 _requestId, uint256 _payment, bytes4 _callbackFunc, uint256 _expiration ) external override { bytes32 paramsHash = keccak256( abi.encodePacked( _payment, msg.sender, _callbackFunc, _expiration) ); require(paramsHash == commitments[_requestId], \u0026quot;Params do not match request ID\u0026quot;); // solhint-disable-next-line not-rely-on-time require(_expiration \u0026lt;= now, \u0026quot;Request is not expired\u0026quot;); delete commitments[_requestId]; emit CancelOracleRequest(_requestId); assert(LinkToken.transfer(msg.sender, _payment)); } ","permalink":"https://link2.guru/blog/chainlink%E5%90%88%E7%BA%A6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902/","tags":["Chainlink"],"title":"chainlink合约源码分析（2）"},{"categories":["Block Chain","Chainlink"],"contents":"今天我们分析chainlink合约源码。\nChainlinkClient.sol 位置ChainlinkClient.sol\n主要代码 /** * @notice 构建一个ChainlinkRequest * @param _specId node 节点创建的jobId * @param _callbackAddress 请求成功数据回调的地址 * @param _callbackFunctionSignature 回调地址对应的function * @return A Chainlink Request struct in memory */ function buildChainlinkRequest( bytes32 _specId, address _callbackAddress, bytes4 _callbackFunctionSignature ) internal pure returns (Chainlink.Request memory) { Chainlink.Request memory req; return req.initialize(_specId, _callbackAddress, _callbackFunctionSignature); } /** * @notice 向指定的oracle地址创建一个请求 * @dev 创建并存储一个请求ID, 增加本地的nonce值, 并使用`transferAndCall` 方法发送LINK， * 创建到目标oracle合约地址的请求 * 发出 ChainlinkRequested 事件. * @param _oracle 发送请求至的oracle地址 * @param _req 完成初始化的Chainlink请求 * @param _payment 请求发送的LINK数量 * @return 请求 ID */ function sendChainlinkRequestTo(address _oracle, Chainlink.Request memory _req, uint256 _payment) internal returns (bytes32 requestId) { requestId = keccak256(abi.encodePacked(this, requestCount)); _req.nonce = requestCount; pendingRequests[requestId] = _oracle; emit ChainlinkRequested(requestId); require(link.transferAndCall(_oracle, _payment, encodeRequest(_req)), \u0026quot;unable to transferAndCall to oracle\u0026quot;); requestCount += 1; return requestId; } /** * @notice 取消一个还没有回调的ChainlinkRequest * @dev 需要记录录一个过期值 * 从pendingRequests删除对应request * 触发ChainlinkCancelled事件 * @param _requestId The request ID * @param _payment 请求发送的LINK数量 * @param _callbackFunc 请求回调指定的function * @param _expiration 请求过期的时间 */ function cancelChainlinkRequest( bytes32 _requestId, uint256 _payment, bytes4 _callbackFunc, uint256 _expiration ) internal { ChainlinkRequestInterface requested = ChainlinkRequestInterface(pendingRequests[_requestId]); delete pendingRequests[_requestId]; emit ChainlinkCancelled(_requestId); requested.cancelOracleRequest(_requestId, _payment, _callbackFunc, _expiration); } 其中 link.transferAndCall 方法即是 ERC677 定义的 token 转账方法，与 ERC20 的 transfer 方法相比，它多了一个 data 字段，可以在转账的同时携带数据。这里就将之前打包好的请求数据放在了 data 字段，跟随转账一起发送到了 Oracle 合约。transferAndCall 方法定义如下\n/** * @dev 将token和额外数据一起转移给一个合约地址 * @param _to 转移到的目的地址 * @param _value 转移数量 * @param _data 传递给接收合约的额外数据 */ function transferAndCall(address _to, uint _value, bytes _data) public returns (bool success) { } ","permalink":"https://link2.guru/blog/chainlink%E5%90%88%E7%BA%A6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/","tags":["Chainlink"],"title":"chainlink合约源码分析（1）"},{"categories":["Block Chain"],"contents":"注册钱包 首先你创建主网钱包地址，并激活。wallet.near.org\n部署主网节点（非验证节点）  clone nearcore  git clone https://github.com/near/nearcore.git 设置环境变量  export NEAR_RELEASE_VERSION=$(curl -s https://github.com/near/nearcore/releases/latest | tr '/\u0026quot; ' '\\n' | grep \u0026quot;[0-9]\\.[0-9]*\\.[0-9]\u0026quot; | head -n 1) 3 切换分支\ncd nearcore git checkout $NEAR_RELEASE_VERSION 构建nearcore,时间比较长，耐心等待。  cargo build -p neard --release 5.配置chain-id和account-id\ntarget/release/neard init --chain-id=\u0026quot;mainnet\u0026quot; --account-id=\u0026lt;YOUR_STAKING_POOL_ID\u0026gt; 启动节点  6.1 修改config.json配置文件。\n使用config.json覆盖.near/config.json\n6.2 防火墙需要打开24567端口\n6.3 运行下面命令\ntarget/release/neard run 节点已经运行，等待同步就可以了。\nRPC端口:3030。\n使用tmux后台云运行  参考 deploy-on-mainnet\n","permalink":"https://link2.guru/blog/how-to-run-mainnet-on-near/","tags":["Near"],"title":"运行Near主网节点（非验证节点）"}]